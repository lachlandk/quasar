self.Quasar=new function(){this.add=function(e,t){const i=new this.Expression(new this.Node("operator","+"));return i.root.left=e.root,i.root.right=t.root,i},this.gcd=function(e,t){let i=Math.max(Math.abs(e),Math.abs(t)),s=Math.min(Math.abs(e),Math.abs(t));for(;0!==s;){let e=i%s;i=s,s=e}return i},this.bezout=function(e,t){let i=Math.max(Math.abs(e),Math.abs(t)),s=Math.min(Math.abs(e),Math.abs(t)),r=1,a=0,o=0,n=1;for(;0!==s;){let e=Math.floor(i/s),t=i-e*s,p=r-e*a,h=o-e*n;i=s,r=a,o=n,s=t,a=p,n=h}return[o,r]},this.lcm=function(e,t){return Math.abs(e*t)/this.gcd(e,t)},this.Node=function(e,t,i){this.type=e,this.value=t,this.properties={};for(const e in i)this.properties[e]=i[e];this.left=null,this.right=null},this.Expression=function(e=null){this.root=e},this.parse=function(e){const t=e.match(/\d+|\S/gi),i=[];if(!t)return new this.Expression;t.forEach(function(e,t){if(e.match(/\d+/))i.push({type:"constant",value:parseInt(e)});else if(e.match(/[a-z]/i))i.push({type:"variable",value:e});else if(e.match(/[+\-*/^]/))e.match(/\^/)?i.push({type:"operator",value:"^",associativity:"right",precedence:1}):e.match(/[\/*]/)?i.push({type:"operator",value:e,associativity:"left",precedence:2}):e.match(/[+-]/)&&i.push({type:"operator",value:e,associativity:"left",precedence:3});else if(e.match(/\(/))i.push({type:"open-parenthesis",value:"("});else{if(!e.match(/\)/))throw{name:"LexingError",msg:"Unknown Token: "+e};i.push({type:"close-parenthesis",value:")"})}});for(let e=0;e<i.length;e++)if(0===e||"variable"!==i[e].type&&"constant"!==i[e].type&&"open-parenthesis"!==i[e].type){if("operator"===i[e].type&&("-"===i[e].value&&i[e+1]&&"-"===i[e+1].value&&(i[e]={type:"operator",value:"+",associativity:"left",precedence:3},i.splice(e+1,1)),!i[e].value.match(/[+-]/)||0!==e&&"operator"!==i[e-1].type&&"open-parenthesis"!==i[e-1].type||("-"===i[e].value?i[e]={type:"operator",value:"~",precedence:0}:"+"===i[e].value&&i.splice(e,1)),i[e]&&i[e].value.match(/[/*-+^]/)&&(i[e-1]&&"operator"===i[e-1].type||!i[e-1]||!i[e+1])))throw{name:"ParsingError",msg:"Invalid operands for operator: "+i[e].value}}else"variable"!==i[e-1].type&&"constant"!==i[e-1].type&&"close-parenthesis"!==i[e-1].type||i.splice(e,0,{type:"operator",value:"*",associativity:"left",precedence:2});const s=[],r=[];for(;0!==i.length;){const e=i.shift();if("constant"===e.type||"variable"===e.type)s.push(e);else if("open-parenthesis"===e.type)r.unshift(e);else if("close-parenthesis"===e.type){for(;"open-parenthesis"!==r[0].type;)if(s.push(r.shift()),0===r.length)throw{name:"ParsingError",msg:"Mismatched delimiter: )"};r.shift()}else if("operator"===e.type)if("left"===e.associativity){for(;0!==r.length&&"operator"===r[0].type&&r[0].precedence<=e.precedence;)s.push(r.shift());r.unshift(e)}else if("right"===e.associativity){for(;0!==r.length&&r[0].precedence<e.precedence;)s.push(r.shift());r.unshift(e)}else r.unshift(e)}for(;0!==r.length;){if("open-parenthesis"===r[0].type)throw{name:"ParsingError",msg:"Mismatched delimiter: )"};s.push(r.shift())}s.forEach(function(e,t){if("variable"===e.type||"constant"===e.type)r.unshift(new this.Node(e.type,e.value));else if("operator"===e.type)if(0===e.precedence){let t=new this.Node(e.type,e.value);t.left=r.shift(),r.unshift(t)}else{let t=new this.Node(e.type,e.value);t.right=r.shift(),r.length>0&&(t.left=r.shift()),r.unshift(t)}},this);const a=new this.Expression(r[0]);return function e(t,i){t&&"operator"===t.type&&(e(t.left,i),e(t.right,i),"^"===t.value&&"variable"===t.left.type&&"constant"===t.right.type&&(t.type="variable",t.value=t.left.value,t.properties.coefficient=1,t.properties.power=t.right.value,t.left=null,t.right=null),"*"===t.value&&"constant"===t.left.type&&"variable"===t.right.type&&(t.type="variable",t.value=t.right.value,t.properties.coefficient=t.left.value,t.properties.power=t.right.properties.power?t.right.properties.power:1,t.left=null,t.right=null))}(a.root,this),a}};