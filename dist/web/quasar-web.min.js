self.Quasar=new function(){this.gcd=function(e,t){let s=Math.max(Math.abs(e),Math.abs(t)),i=Math.min(Math.abs(e),Math.abs(t));for(;0!==i;){let e=s%i;s=i,i=e}return s},this.bezout=function(e,t){let s=Math.max(Math.abs(e),Math.abs(t)),i=Math.min(Math.abs(e),Math.abs(t)),n=1,p=0,a=0,o=1;for(;0!==i;){let e=Math.floor(s/i),t=s-e*i,r=n-e*p,h=a-e*o;s=i,n=p,a=o,i=t,p=r,o=h}return[a,n]},this.lcm=function(e,t){return Math.abs(e*t)/this.gcd(e,t)},this.Node=function(e,t,s){this.type=e,this.value=t,this.properties={};for(const e in s)s.hasOwnProperty(e)&&(this.properties[e]=s[e])},this.Expression=function(){this.tree=[],this.append=function(e){this.tree.unshift(e)}},this.parse=function(e){const t=e.match(/\d+|\S/gi);let s=[];t.forEach(function(e,t){if(e.match(/\d+/))s.push(new this.Node("constant",parseInt(e)));else if(e.match(/[a-z]/i))s.push(new this.Node("variable",e));else if(e.match(/[+\-*/^]/))e.match(/\^/)?s.push(new this.Node("operator","^",{associativity:"right",precedence:1})):e.match(/[\/*]/)?s.push(new this.Node("operator",e,{associativity:"left",precedence:2})):e.match(/[+-]/)&&s.push(new this.Node("operator",e,{associativity:"left",precedence:3}));else if(e.match(/\(/))s.push(new this.Node("open-parenthesis","("));else{if(!e.match(/\)/))throw{name:"LexingError",msg:"Unknown Token"+e};s.push(new this.Node("close-parenthesis",")"))}},this);for(let e=0;e<s.length;e++)"function"!==s[e].type||"open-parenthesis"===s[e+1].type||"variable"!==s[e+1].type&&"constant"!==s[e+1].type||(s.splice(e+1,0,new this.Node("open-parenthesis","(")),s.splice(e+3,0,new this.Node("close-parenthesis",")"))),0===e||"variable"!==s[e].type&&"constant"!==s[e].type&&"open-parenthesis"!==s[e].type&&"function"!==s[e].type?"operator"===s[e].type&&(!s[e].value.match(/[+-]/)||0!==e&&"operator"!==s[e-1].type&&"open-parenthesis"!==s[e-1].type&&"delimiter"!==s[e-1].type||("-"===s[e].value?s[e]=new this.Node("operator","~",{precedence:0}):s.splice(e,1))):"variable"!==s[e-1].type&&"constant"!==s[e-1].type&&"close-parenthesis"!==s[e-1].type||s.splice(e,0,new this.Node("operator","*",{associativity:"left",precedence:2}));let i=new this.Expression,n=[];for(;0!==s.length;){let e=s.shift();if("constant"===e.type||"variable"===e.type)i.append(e);else if("function"===e.type||"open-parenthesis"===e.type)n.unshift(e);else if("delimiter"===e.type||"close-parenthesis"===e.type){for(;"open-parenthesis"!==n[0].type;)i.append(n.shift());"close-parenthesis"===e.type&&(n.shift(),0!==n.length&&"function"===n[0].type&&i.append(n.shift()))}else if("operator"===e.type)if("left"===e.properties.associativity){for(;0!==n.length&&"operator"===n[0].type&&n[0].properties.precedence<=e.properties.precedence;)i.append(n.shift());n.unshift(e)}else if("right"===e.properties.associativity){for(;0!==n.length&&n[0].properties.precedence<e.properties.precedence;)i.append(n.shift());n.unshift(e)}else n.unshift(e)}for(;0!==n.length;)i.append(n.shift());return i}};