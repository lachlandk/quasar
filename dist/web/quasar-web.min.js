self.Quasar=new function(){this.add=function(e,t){const s=new this.Expression(new this.Node("operator","+"));return s.root.left=e.root,s.root.right=t.root,s},this.gcd=function(e,t){let s=Math.max(Math.abs(e),Math.abs(t)),a=Math.min(Math.abs(e),Math.abs(t));for(;0!==a;){let e=s%a;s=a,a=e}return s},this.bezout=function(e,t){let s=Math.max(Math.abs(e),Math.abs(t)),a=Math.min(Math.abs(e),Math.abs(t)),i=1,r=0,n=0,o=1;for(;0!==a;){let e=Math.floor(s/a),t=s-e*a,h=i-e*r,p=n-e*o;s=a,i=r,n=o,a=t,r=h,o=p}return[n,i]},this.lcm=function(e,t){return Math.abs(e*t)/this.gcd(e,t)},this.Node=function(e,t){this.type=e,this.value=t,this.left=null,this.right=null},this.Expression=function(e=null){this.root=e},this.parse=function(e){const t=e.match(/\d+|\S/gi),s=[];if(!t)return new this.Expression;t.forEach(function(e,t){if(e.match(/\d+/))s.push({type:"constant",value:parseInt(e)});else if(e.match(/[a-z]/i))s.push({type:"variable",value:e});else if(e.match(/[+\-*/^]/))e.match(/\^/)?s.push({type:"operator",value:"^",associativity:"right",precedence:1}):e.match(/[\/*]/)?s.push({type:"operator",value:e,associativity:"left",precedence:2}):e.match(/[+-]/)&&s.push({type:"operator",value:e,associativity:"left",precedence:3});else if(e.match(/\(/))s.push({type:"open-parenthesis",value:"("});else{if(!e.match(/\)/))throw{name:"LexingError",msg:"Unknown Token: "+e};s.push({type:"close-parenthesis",value:")"})}});for(let e=0;e<s.length;e++)if(0===e||"variable"!==s[e].type&&"constant"!==s[e].type&&"open-parenthesis"!==s[e].type){if("operator"===s[e].type&&(!s[e].value.match(/[+-]/)||0!==e&&"operator"!==s[e-1].type&&"open-parenthesis"!==s[e-1].type||("-"===s[e].value?s[e]={type:"operator",value:"~",precedence:0}:"+"===s[e].value&&s.splice(e,1)),s[e]&&s[e].value.match(/[/*-+^]/)&&(s[e-1]&&"operator"===s[e-1].type||!s[e-1]||!s[e+1])))throw{name:"ParsingError",msg:"Invalid operands for operator: "+s[e].value}}else"variable"!==s[e-1].type&&"constant"!==s[e-1].type&&"close-parenthesis"!==s[e-1].type||s.splice(e,0,{type:"operator",value:"*",associativity:"left",precedence:2});const a=[],i=[];for(;0!==s.length;){const e=s.shift();if("constant"===e.type||"variable"===e.type)a.push(e);else if("open-parenthesis"===e.type)i.unshift(e);else if("close-parenthesis"===e.type){for(;"open-parenthesis"!==i[0].type;)if(a.push(i.shift()),0===i.length)throw{name:"ParsingError",msg:"Mismatched delimiter: )"};i.shift()}else if("operator"===e.type)if("left"===e.associativity){for(;0!==i.length&&"operator"===i[0].type&&i[0].precedence<=e.precedence;)a.push(i.shift());i.unshift(e)}else if("right"===e.associativity){for(;0!==i.length&&i[0].precedence<e.precedence;)a.push(i.shift());i.unshift(e)}else i.unshift(e)}for(;0!==i.length;){if("open-parenthesis"===i[0].type)throw{name:"ParsingError",msg:"Mismatched delimiter: )"};a.push(i.shift())}return a}};